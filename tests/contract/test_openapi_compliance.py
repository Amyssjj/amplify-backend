"""
Contract tests validating OpenAPI specification compliance.
"""
import pytest
import yaml
from fastapi import status
from fastapi.openapi.utils import get_openapi
from main import app
import os


@pytest.mark.contract
class TestOpenAPISpecCompliance:
    """Test that API implementation matches OpenAPI specification."""

    @pytest.fixture(scope="class")
    def openapi_spec(self):
        """Load OpenAPI specification from YAML file."""
        spec_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), "openapi.yaml")

        with open(spec_path, 'r') as f:
            return yaml.safe_load(f)

    @pytest.fixture(scope="class")
    def generated_spec(self):
        """Get OpenAPI spec generated by FastAPI."""
        return get_openapi(
            title=app.title,
            version=app.version,
            description=app.description,
            routes=app.routes,
        )

    def test_api_info_matches_spec(self, openapi_spec, generated_spec):
        """Test that API info matches OpenAPI specification."""
        # Check title
        assert generated_spec["info"]["title"] == "Amplify Backend API"

        # Check description
        assert "Backend service" in generated_spec["info"]["description"]

        # Check version format
        assert "version" in generated_spec["info"]

    def test_required_endpoints_exist(self, client, openapi_spec):
        """Test that all required endpoints from OpenAPI spec exist."""
        required_endpoints = [
            # Health endpoints
            ("/api/v1/health/", "get"),

            # Enhancement endpoints
            ("/api/v1/enhancements", "post"),
            ("/api/v1/enhancements", "get"),

            # Auth endpoints
            ("/api/v1/auth/google", "post"),
        ]

        for endpoint, method in required_endpoints:
            if method.lower() == "get":
                response = client.get(endpoint)
            elif method.lower() == "post":
                # Use minimal valid data for POST requests
                if "enhancements" in endpoint:
                    response = client.post(endpoint, json={
                        "photo_base64": "fake_base64_data",
                        "transcript": "Test story",
                        "language": "en"
                    })
                elif "auth" in endpoint:
                    response = client.post(endpoint, json={
                        "id_token": "fake_token"
                    })
                else:
                    response = client.post(endpoint, json={})

            # Endpoint should exist (not return 404)
            assert response.status_code != status.HTTP_404_NOT_FOUND

    def test_endpoint_paths_match_spec(self, openapi_spec):
        """Test that endpoint paths match OpenAPI specification."""
        spec_paths = set(openapi_spec.get("paths", {}).keys())

        expected_paths = {
            "/api/v1/health/",
            "/api/v1/health/detailed",
            "/api/v1/enhancements",
            "/api/v1/enhancements/{enhancement_id}",
            "/api/v1/enhancements/{enhancement_id}/audio",
            "/api/v1/auth/google"
        }

        # Check that key paths are defined in spec
        assert "/api/v1/health/" in spec_paths
        assert "/api/v1/enhancements" in spec_paths
        assert "/api/v1/auth/google" in spec_paths

    def test_enhancement_request_schema_compliance(self, client, sample_enhancement_request):
        """Test that enhancement requests match OpenAPI schema."""
        response = client.post("/api/v1/enhancements", json=sample_enhancement_request)

        # Should accept valid request matching OpenAPI schema
        assert response.status_code == status.HTTP_200_OK

        # Test invalid requests fail appropriately
        invalid_requests = [
            {},  # Missing all required fields
            {"photo_base64": "fake"},  # Missing transcript
            {"transcript": "story"},  # Missing photo_base64
            {
                "photo_base64": "fake",
                "transcript": "story",
                "language": "invalid"  # Invalid language format
            }
        ]

        for invalid_request in invalid_requests:
            response = client.post("/api/v1/enhancements", json=invalid_request)
            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

    def test_enhancement_response_schema_compliance(self, client, sample_enhancement_request):
        """Test that enhancement responses match OpenAPI schema."""
        response = client.post("/api/v1/enhancements", json=sample_enhancement_request)

        assert response.status_code == status.HTTP_200_OK
        data = response.json()

        # Check EnhancementTextResponse schema compliance
        required_fields = ["enhancement_id", "enhanced_transcript", "insights"]
        for field in required_fields:
            assert field in data

        # Check enhancement_id format (should match pattern ^enh_[a-zA-Z0-9]+$)
        enhancement_id = data["enhancement_id"]
        assert enhancement_id.startswith("enh_")
        assert len(enhancement_id) > 4  # More than just "enh_"

        # Check insights is a dictionary
        assert isinstance(data["insights"], dict)

    def test_audio_response_schema_compliance(self, client, sample_enhancement_request):
        """Test that audio responses match OpenAPI schema."""
        # Create enhancement first
        enhancement_response = client.post("/api/v1/enhancements", json=sample_enhancement_request)
        enhancement_data = enhancement_response.json()
        enhancement_id = enhancement_data["enhancement_id"]

        # Get audio
        audio_response = client.get(f"/api/v1/enhancements/{enhancement_id}/audio")

        assert audio_response.status_code == status.HTTP_200_OK
        audio_data = audio_response.json()

        # Check EnhancementAudioResponse schema compliance
        required_fields = ["audio_base64", "audio_format"]
        for field in required_fields:
            assert field in audio_data

        # Check audio_format is mp3
        assert audio_data["audio_format"] == "mp3"

        # Check audio_base64 is non-empty string
        assert isinstance(audio_data["audio_base64"], str)
        assert len(audio_data["audio_base64"]) > 0

    def test_history_response_schema_compliance(self, client):
        """Test that history responses match OpenAPI schema."""
        response = client.get("/api/v1/enhancements")

        assert response.status_code == status.HTTP_200_OK
        data = response.json()

        # Check response structure matches OpenAPI schema
        required_fields = ["total", "items"]
        for field in required_fields:
            assert field in data

        # Check field types
        assert isinstance(data["total"], int)
        assert isinstance(data["items"], list)

        # If items exist, check their structure
        for item in data["items"]:
            if item:  # If not empty placeholder
                expected_item_fields = ["enhancement_id", "created_at", "transcript_preview", "audio_status"]
                for field in expected_item_fields:
                    # Note: May not be fully implemented yet
                    pass

    def test_auth_request_schema_compliance(self, client, sample_google_auth_request):
        """Test that auth requests match OpenAPI schema."""
        response = client.post("/api/v1/auth/google", json=sample_google_auth_request)

        # Should accept valid schema but may fail at token verification
        # Valid responses: 200 (success), 401 (auth failed), 422 (invalid token), 503 (service unavailable)
        assert response.status_code in [200, 401, 422, 503]

        # Test invalid requests fail appropriately
        invalid_requests = [
            {},  # Missing id_token
            {"id_token": ""},  # Empty id_token
        ]

        for invalid_request in invalid_requests:
            response = client.post("/api/v1/auth/google", json=invalid_request)
            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

    def test_error_response_schema_compliance(self, client):
        """Test that error responses match OpenAPI schema."""
        # Trigger a validation error
        response = client.post("/api/v1/enhancements", json={})

        assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
        data = response.json()

        # Should match ValidationErrorResponse schema
        assert "error" in data
        assert data["error"] == "VALIDATION_ERROR"
        assert "message" in data
        assert "validation_errors" in data
        assert isinstance(data["validation_errors"], list)

        # Each validation error should have field and message
        if data["validation_errors"]:
            error = data["validation_errors"][0]
            assert "field" in error
            assert "message" in error

    def test_path_parameters_validation(self, client):
        """Test path parameter validation matches OpenAPI spec."""
        # Test invalid enhancement_id format
        invalid_ids = [
            "invalid_id",  # Doesn't match pattern
            "enh_",  # Too short
            "wrong_prefix_123",  # Wrong prefix
        ]

        for invalid_id in invalid_ids:
            response = client.get(f"/api/v1/enhancements/{invalid_id}")
            # Should return 422 for invalid path parameter format
            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

        # Test valid format (should not return 422)
        valid_id = "enh_abc123"
        response = client.get(f"/api/v1/enhancements/{valid_id}")
        assert response.status_code != status.HTTP_422_UNPROCESSABLE_ENTITY

    def test_query_parameters_validation(self, client):
        """Test query parameter validation matches OpenAPI spec."""
        # Test invalid pagination parameters
        invalid_params = [
            "?limit=100",  # Exceeds maximum of 50
            "?limit=0",   # Below minimum of 1
            "?offset=-1", # Below minimum of 0
        ]

        for params in invalid_params:
            response = client.get(f"/api/v1/enhancements{params}")
            assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY

        # Test valid parameters
        valid_params = [
            "?limit=20&offset=0",
            "?limit=50&offset=10",
            "",  # Default values
        ]

        for params in valid_params:
            response = client.get(f"/api/v1/enhancements{params}")
            assert response.status_code == status.HTTP_200_OK


@pytest.mark.contract
class TestOpenAPIDocumentation:
    """Test OpenAPI documentation and metadata."""

    def test_openapi_endpoint_accessibility(self, client):
        """Test that OpenAPI documentation is accessible."""
        response = client.get("/api/v1/openapi.json")

        assert response.status_code == status.HTTP_200_OK
        assert "application/json" in response.headers["content-type"]

        # Should be valid JSON
        openapi_doc = response.json()
        assert "openapi" in openapi_doc
        assert "info" in openapi_doc
        assert "paths" in openapi_doc

    def test_api_tags_consistency(self, client):
        """Test that API tags are consistent with OpenAPI spec."""
        response = client.get("/api/v1/openapi.json")
        openapi_doc = response.json()

        # Check that tags are defined
        if "tags" in openapi_doc:
            tag_names = [tag["name"] for tag in openapi_doc["tags"]]
            expected_tags = ["Health", "Enhancement", "Auth"]

            # At least some expected tags should be present
            for tag in expected_tags:
                # Note: May not all be implemented yet
                pass

    def test_security_schemes_defined(self, client):
        """Test that security schemes are defined in OpenAPI spec."""
        response = client.get("/api/v1/openapi.json")
        openapi_doc = response.json()

        # Should have components section with security schemes
        if "components" in openapi_doc and "securitySchemes" in openapi_doc["components"]:
            security_schemes = openapi_doc["components"]["securitySchemes"]

            # Should define bearer token authentication
            if "BearerAuth" in security_schemes:
                bearer_auth = security_schemes["BearerAuth"]
                assert bearer_auth["type"] == "http"
                assert bearer_auth["scheme"] == "bearer"
